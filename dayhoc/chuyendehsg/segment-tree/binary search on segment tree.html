<html xmlns:m="http://www.w3.org/1998/Math/MathML">
<head>
 <meta charset="utf8"/>
 <title>Binary search over segment tree</title>
 <meta name="author" value="Tran Huu Nam"/>
 <link rel="stylesheet" href="../../inc/chung.css">
 <link rel="stylesheet" href="../../inc/mathjax/mathjax_styles.css">
 <script src="../../inc/mathjax/tex-mml-chtml.js" id="MathJax-script" async></script>
 <script src="../../inc/jquery.min.js" type="text/javascript"></script>
 <script src="../../inc/jquery-ui.min.js" type="text/javascript"></script>
 <link rel="stylesheet" href="../../inc/jquery-ui.min.css">
 <script src="../../inc/chung.js" type="text/javascript"></script>
 
</head>
<body>

<h1>Chặt nhị phân trên segment tree - Binary search over segment tree.</h1>
<h2 id="bài-toán-1">Bài toán 1</h2>
<p>Cho một mảng các số nguyên \(a\) có \(n\) phần tử. Có \(q\) truy vấn có dạng:</p>
<ul>
  <li>\(k\): tìm \(i\) nhỏ nhất sao cho \(a[i] \le k\)</li>
</ul>

<h3 id="cách-giải">Cách giải</h3>
<p>Ta nhận thấy do \(a[i] \le k\) và \(i\) nhỏ nhất, cho nên \(a[j] &gt; k\) với mọi \(1 \le j &lt; i\).</p>

<p>Do đó, \(min(a[1], a[2], ..., a[i]) = a[i]\).</p>

<p>Đặt \(f[i] = min(a[1], a[2], ..., a[i])\).</p>

<p><strong>Nhận xét 1</strong>: Việc tìm \(i\) nhỏ nhất sao cho \(a[i] \le k\) cũng tương ứng với việc tìm \(i\) nhỏ nhất sao cho \(f[i] \le k\).</p>

<p><strong>Nhận xét 2</strong>: \(f[i - 1] \ge f[i]\). Nói cách khác, \(f\) là mảng không tăng.</p>

<p>Vậy bài toán có thể phát biểu lại như sau:</p>

<p>Cho một mảng các số nguyên \(f\) đã “sắp xếp” giảm dần, có \(q\) truy vấn có dạng:</p>
<ul>
  <li>\(k\): tìm \(i\) nhỏ nhất sao cho \(f[i] \le k\).</li>
</ul>

<p>Rõ ràng bài toán này chỉ là bài toán chặt nhị phân cơ bản, vì mảng \(f\) đã được “sắp xếp”. Tới đây ta có thể trả lời các truy vấn trong độ phức tạp \(O(logn)\). Code thì nó sẽ giống giống thế này:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> 
            <span class="n">pos</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> 
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="bài-toán-2">Bài toán 2</h2>
<p>Cho một mảng các số nguyên \(a\) có \(n\) phần tử. Có \(q\) truy vấn có dạng:</p>
<ul>
  <li>\(i\) \(x\): gán \(a[i] = x\).</li>
  <li>\(k\): tìm \(i\) nhỏ nhất sao cho \(a[i] \le k\)</li>
</ul>

<p>Bài toán này giống bài toán 1, nhưng có thêm truy vấn cập nhật phần tử, điều này làm cho mảng \(f\) bị thay đổi. Ta có thể sửa lại yêu cầu bài toán một chút, là có 3 loại truy vấn:</p>
<ul>
  <li>\(i\) \(x\): gán \(a[i] = x\).</li>
  <li>\(k\): tìm \(i\) nhỏ nhất sao cho \(a[i] \le k\)</li>
  <li>\(i\): tính \(min(a[1], a[2], ..., a[i])\).</li>
</ul>

<p>Rõ ràng truy vấn 1 và 3 có thể thực hiện bằng segment tree với độ phức tạp \(O(logn)\), vậy thì tới đây bài toán quay về bài toán 1, chỉ có điều khi ta cần tính \(f[i]\) thì ta phải gọi hàm trên segment tree để lấy min, độ phức tạp cho việc trả lời truy vấn 2 là \(O(log^2n)\):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getMin</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> 
            <span class="n">pos</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> 
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Nhưng nếu chỉ dừng ở đây thì đã không cần blog này rồi &lt;(“). Ta nhìn một chút vào cấu trúc cây segment tree (quản lý min) dưới dây:</p>

<p><img src="img/segmentTree.png" alt="" />.</p>

<p>Giả sử ta cần tìm vị trí đầu tiên có giá trị không vượt quá \(2\). Ta đứng từ gốc, xét 2 con trái phải lần lượt có giá trị là 3 và 2: 
<img src="img/segmentTree1.png" alt="" /></p>

<p>Do ta đang cần tìm giá trị không vượt quá 2, nên ta chắc chắn kết quả không nằm trong cây con bên trái (vì min của cây con này là 3, suy ra mọi phần tử được quản lý bởi cây con này đều lớn hơn 2). Và do cây con phải có giá trị là 2, suy ra kết quả chắc chắn nằm cây con này, ta đệ quy xuống cây con bên trái:</p>

<p><img src="img/segmentTree2.png" alt="" /></p>

<p>Tương tự, cây con này có 2 cây con trái và phải, cả 2 đều có giá trị là 2, nghĩa là luôn tồn tại ít nhất một số có giá trị bằng 2 trong cả 2 cây con này, từ đó suy ra cả 2 cây con đều có thể chứa kết quả ta cần tìm. Nhưng do ta muốn tìm vị trí có \(i\) bé nhất, nên ta sẽ ưu tiên đi vào cây con bên trái (cây con này quản lý các vị trí nhỏ hơn các vị trí của cây con phải).</p>

<p><img src="img/segmentTree3.png" alt="" /></p>

<p>Lập luận tương tự thì ta sẽ biết được kết quả nằm ở cây con trái, lúc này cây chỉ quản lý duy nhất một phần tử nên ta có thể kết luận luôn vị trí cần tìm.</p>

<p>Đoạn code mẫu cho việc tìm vị trí đầu tiên không vượt quá số \(k\) có thể code như sau, lưu ý, trong code này mình xem mảng \(st\) là mảng lưu giá trị của segment tree, 3 tham số \(root, l, r\) thể hiện cho việc nút \(root\) quản lý một đoạn từ \([l, r]\):</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//nếu cả đoạn [l, r] đều lớn hơn k thì không thỏa mãn</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span> <span class="c1">//khi đoạn có 1 phần tử thì đó là kết quả</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//nếu min cây con trái không vượt quá k</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="c1">//ngược lại thì kết quả nằm ở bên cây con phải</span>
    <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//cout &lt;&lt; query(1, 1, n, k);</span>
</code></pre></div></div>

<p>Hàm trên có độ phức tạp là \(O(logn)\), bởi vì mỗi lần đệ quy chỉ gọi ra một hàm khác (từ một nút chỉ đi qua một nút khác), và số lần gọi đệ quy chính bằng độ cao của segment tree.
Tới đây ta đã xong bài toán 2.</p>

<p>Lưu ý là, với các bài toán mà truy vấn cập nhật là một đoạn (thay vì một phần tử như bài toán 2), thì việc cài đặt hàm \(query\) ở trên vẫn không đổi, chỉ có thêm vào lazy trước khi xét 2 cây con trái phải, mình xin giành cho bạn đọc vậy.</p>

<h2 id="bài-toán-3">Bài toán 3:</h2>
<p>Cho một mảng các số nguyên \(a\) có \(n\) phần tử. Có \(q\) truy vấn có dạng:</p>
<ul>
  <li>\(i\) \(x\): gán \(a[i] = x\).</li>
  <li>\(L\) \(k\): tìm \(i\) nhỏ nhất sao cho \(L \le i\) và \(a[i] \le k\)</li>
</ul>

<p>Bài toán này khó hơn bài toán 2 một chút, đó là có thêm một cận dưới của $i$ (thay vì tìm \(i\) bé nhất, thì ta cần tìm \(i\) bé nhất nhưng lớn hơn một số nào đó), ta có thể thay đổi code một tí như sau:</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lowerbound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//nếu cả đoạn [l, r] đều lớn hơn k thì không thỏa mãn</span>
  	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">lowerbound</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//ta chỉ xét những vị trí không nhỏ hơn lowerbound</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span> <span class="c1">//khi đoạn có 1 phần tử thì đó là kết quả</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//nếu min cây con trái không vượt quá k</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">lowerbound</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
  	<span class="c1">//nếu cây con trái không tìm được kết quả &lt;=&gt; min nằm ngoài lowerbound</span>
    <span class="c1">//thì ta sẽ tìm kết quả ở cây con phải</span>
  	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
      	<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">lowerbound</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//cout &lt;&lt; query(1, 1, n, l, k);</span>
</code></pre></div></div>
<p>Code này có một chút lạ, khác so với code ở bài toán 2 một chút, ở bài toán 2, thì mỗi lần đệ quy chỉ thăm duy nhất một con trái hoặc phải, nhưng ở code mới này thì một lần đệ quy có thể phải thăm cả 2 con, lý do là vì có thể một cây con nó có min không vượt quá \(k\), nhưng vị trí đạt min nó có thể nhỏ hơn lowerbound, vì thế ta phải tìm ở cây con khác.</p>

<p>Để đánh giá độ phức tạp code trên thì hơi rườm rà một chút, nhưng nó vẫn là \(O(logn)\). Đại ý là ta có thể chứng minh số lần mà \(r &lt; lowerbound\) sẽ không quá \(O(logn)\).</p>

</body>
</html>